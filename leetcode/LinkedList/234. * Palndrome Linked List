# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        val = []
        while head is not None:
            val.append(head.val)
            head = head.next
        return val == val[::-1]
Time: O(n)
Space: O(n)

extracted value and then compare reverse with original

class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        
        self.front = head
        
        def recursive_check (curr=head) -> bool:
            if curr is not None:
                if not recursive_check(curr.next):
                    return False
                if self.front.val != curr.val:
                    return False
                self.front = self.front.next
            return True
        
        return recursive_check()
Time: O(n)
Space: O(n)

stack used in recursion. recursion uses stack to reverse travel through each value in the linked list,
and return true if empty inputs, and compare front pointer with the end of linked list in the top element in program stack 

class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        if head is None:
            return True
        
        first_half_end = self.get_end_of_first_half(head)
        second_half_start = self.reverseList(first_half_end.next)
        result = True
        first_position = head
        second_position = second_half_start
        while second_position is not None:
            if first_position.val != second_position.val:
                result = False
            first_position = first_position.next
            second_position = second_position.next
        
        first_half_end.next = self.reverseList(second_half_start)
        
        return result
            
    def get_end_of_first_half(self,curr):
        quick = curr
        slow = curr
        while quick.next is not None and quick.next.next is not None:
            slow = slow.next
            quick = quick.next.next
        return slow 

    def reverseList(self, head):
        prev = None
        curr = head
        while curr is not None:
            nextTemp = curr.next
            curr.next = prev
            prev = curr
            curr = nextTemp
        return prev
        
Time: O(n)
Space: O(1)

reach the second half via slow-quick, returns slow(the first half), then reverse the second half via slow.next and return the head of second half, loop through
first half and second half. result is for reverse back second half
